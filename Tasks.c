/*-----------------------------------------------------------------------------
Filename: Tasks.c
Description: This file sets up and arranges the timer.
Generated by Musa ÇUFALCI. Friday February 08 08.02.2019
----------------------------------------------------------------------------- */
/*
-----------------------------------------------------------------------------
A U T H O R I D E N T I T Y
-----------------------------------------------------------------------------
Initials Name Company
---------- --------------------- --------------------------------------------
Musa  ÇUFALCI
-----------------------------------------------------------------------------
R E V I S I O N H I S T O R Y
-----------------------------------------------------------------------------
Date Author Modification Description
Type
---------- ------ ------------- ----------------------------------
2016-03-29 MK Added First creating after project editing
----------------------------------------------------------------------------
*/


#include "Tasks.h"
/******************************************************************************
* Global variables
******************************************************************************/
UINT32 rpm_constant = 7776; // 59100step / 760Hz = 77,76
volatile UINT32 working_hour = 0;
UINT8 no_ignition_counter = 0;
bool no_ignition_flag = FALSE;
bool button_clicked_flag = FALSE;
bool ignition_interrupt_flag = FALSE;
bool ignition_on_flag = FALSE;

state State = Default_state;
UINT32 temp_rpm_constant = 0;
UINT8 eeprom_error = 0;			//MISRA added return val

UINT32 des_pos = 0;

UINT16 rpm_array[50] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
					0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
UINT16 rpm_hi_res = 0; 
UINT16 rpm_lo_res = 0; 

void KBI_Callback(void);
/******************************************************************************
* 
* @brief    Enables Application level interrupt callbacks
* 			Sets the LCD values
* 			Reads the working hour value from EEPROM
* 			Reads the rpm constant value from EEPROM
* @param    none
* @return   none
* 
******************************************************************************/
void System_Init()
{
	UINT8 ii  = 10;
	GPIO_Set_Callback(KBI_Callback);
	while(ii--)
		Delay(65532);
	
	/* LCD Setups */
	Set_HG(1);
	Set_Trip(0);
	Set_Total(0);
	
    //engine working hour is read from eeprom before counting up the working hours.    
    working_hour = EEPROM_Read_DoubleWord(WORKING_HOUR_ADDR);
    if(working_hour > 999999)
    	working_hour = 0;
	
    //rpm constant is read from eeprom,cdfault value is 59100 / 760 = 77.76   
    rpm_constant = EEPROM_Read_DoubleWord(RPM_CONSTANT_ADDR);
    if (rpm_constant > MAX_RPM_CONST || rpm_constant < MIN_RPM_CONST)
    {
    	rpm_constant = DEFAULT_RPM_CONST;
    	eeprom_error = EEPROM_Erase_Sector(RPM_CONSTANT_ADDR);
    	eeprom_error = EEPROM_Write_DoubleWord(RPM_CONSTANT_ADDR, rpm_constant);
    }	
}

/******************************************************************************
* @brief    Interrupt Callbacks
* 			Push button and ignition interrupts 
* @param    none
* @return   none
******************************************************************************/
void KBI_Callback(void)
{	
	//static UINT8 mode = 0;
	UINT32 j = 65000;

	// for adjusting the rpm constant 
	if(BUTTON_2)
	{				
		GPIO_PIF(T,1,1);
		button_clicked_flag = TRUE;
	}
	// ignition is connected to the power
	// if power is not present save the working hour to the EEPROM and set the stepper to zero
	else if(!IGNITION)
	{
		GPIO_PIF(T,3,1);
		State = Sleep_state;
		// Save working hour before shut down
		eeprom_error = EEPROM_Erase_Sector(WORKING_HOUR_ADDR);	//TODO Write protection & Read check
		eeprom_error = EEPROM_Write_DoubleWord(WORKING_HOUR_ADDR, working_hour);
		
		// Set stepper motor position to zero
		// to do number will be adjusted (200000)
		MC_SetMotorPosition(0, 0);
		while(j--)
		{
			Move_Stepper();
			Delay(2);	
		}		
	}
	else if(IGNITION)
	{
		ignition_counter = 0;
		ignition_interrupt_flag	= TRUE;
		MCU_Reset();
	}
}

/******************************************************************************
* @brief    Displays the working hours
* @param    none
* @return   none
* 
******************************************************************************/
void LCD_Data(void)
{
	//Set_WH(rpm_constant*rpm/100);
	Set_WH(working_hour);
	//Set_WH(rpm_hi_res);
	//Set_WH(RPM_constant);
}
/******************************************************************************
* @brief    RPM Gauge, steps according to the rpm value
* 			max position = 59500 step, 230 degree, 760 Hz, 4000 RPM
* 			rpm_constant is calculated by button
* @param    none
* @return   none
* @description  step motor 1, frequency reading 
* 
******************************************************************************/
void RPM_Read(void)
{	
	static UINT8 index = 0; 
	static UINT32 rpm_prev = 0;
	static UINT16 rpm_freq = 0;
	UINT8 i = 0; 
	static UINT32 rpm_sum = 0;
	
	rpm_freq = Get_RPM_Frequency();
	
	if(rpm_freq < MIN_RPM)
		rpm_freq = 0;
	else if(rpm_freq > MAX_RPM)
		rpm_freq = MAX_RPM;
	
	if(rpm_sum > rpm_array[index]) 	rpm_sum -= rpm_array[index];
	rpm_array[index] = (UINT16)rpm_freq;
	rpm_sum += rpm_array[index];
	rpm_prev = (UINT32)(rpm_sum) / 50;
	rpm_hi_res = (UINT16)((rpm_hi_res + rpm_prev) / 2);
	rpm_lo_res = rpm_hi_res / 10;

	if(index >= 49)	index = 0;
	else        	index++;
	
	if(!freq_too_low)
	{
		des_pos = (UINT32) (rpm_hi_res) * rpm_constant / 1000;	// rpm_constant is 100 times and rpm resulition 10 times bigger so we divide by 1000
		if(des_pos > MAX_STEP)
			des_pos = MAX_STEP;
	}
	else
	{
		des_pos = 0;
		rpm_hi_res = 0;
		rpm_lo_res = 0;
		rpm_sum = 0;
		for(i = 0; i < 50; i++)			//OE 20.0719
			rpm_array[i] = 0;
	}
	
	MC_SetMotorPosition(0, des_pos);
}
/******************************************************************************
* @brief    Reads the GPIOs and sets the related flags 
* 			If ignition is not present, set the flag
* @param    none
* @return   none
* 
******************************************************************************/
void GPIO_Read(void)
{	
	//Ignition
	if(!IGNITION)
	{
		if(no_ignition_counter < 10)				 	no_ignition_counter++;
		else                    						no_ignition_flag = TRUE;
	}
	else
	{
		if(no_ignition_counter > 0)						no_ignition_counter--;
		else									  		no_ignition_flag = FALSE;
	}
}
/******************************************************************************
* @brief    Delay for a while
* @param    UINT32
* @return   none
* 
******************************************************************************/
void Delay(UINT32 delay)
{
  while( delay-- )
    {
      __RESET_WATCHDOG();
    }/*feed the dog*/
}
/******************************************************************************
* @brief    Calculates the rpm constant value 
* @param    none
* @return   none
* 
******************************************************************************/
void Calibrate(void)
{
	if(State == Calibration_state)
	{
		if(BUTTON_2 && step_counter >= TIM_MSEC_150)
		{
			Increment_RPM_constant();
			step_counter = 0;
		}
	}
	else if (State == Timeout_counting_state)
	{
		if(button_clicked_flag)
		{
			timeout_counter = 0;
			button_clicked_flag = FALSE;
			Increment_RPM_constant();						
		}
	}
}
/******************************************************************************
* @brief    Checks the button, if it is pressed for 3 seconds go into the calibration 
* 			state for the rpm constant 
* @param    none
* @return   none
* 
******************************************************************************/
void Button_Check(void)
{
	if(!BUTTON_2 && ((State == Default_state) || (State == Button_counting_state)))
		State = Default_state;
	
	else if(BUTTON_2 && (State == Default_state))
	{
		State = Button_counting_state;
		button_counter = 0;
	}
	
	if(State == Button_counting_state && (button_counter >= TIM_SEC_3))
	{
		State = Calibration_state;
		rpm_constant = 0;
		step_counter = 0;		
	}
	
	if (State == Timeout_counting_state && BUTTON_2 && timeout_counter >= TIM_MSEC_500)
	{
		State = Calibration_state;
		timeout_counter = 0;
		step_counter = 0;
	}
	
	if(State == Calibration_state && !BUTTON_2)
	{
		timeout_counter = 0;
		State = Timeout_counting_state;
	}
	
		
	if(State == Timeout_counting_state && timeout_counter >= TIM_SEC_3)
	{
		State = Timeout_state;
		eeprom_error = EEPROM_Erase_Sector(RPM_CONSTANT_ADDR);
		eeprom_error = EEPROM_Write_DoubleWord(RPM_CONSTANT_ADDR, rpm_constant);
		
		temp_rpm_constant = rpm_constant;
		rpm_constant = 0;
	}		
}
/******************************************************************************
* @brief    Increments the rpm constant 
* @param    none
* @return   none
* 
******************************************************************************/
void Increment_RPM_constant(void)
{
	if(rpm_lo_res < 300 || rpm_lo_res > 4000)
	{
		if( (rpm_constant*rpm_lo_res/100) < MAX_STEP)
			rpm_constant += 80;
	}
	else if(rpm_lo_res >= 300 && rpm_lo_res < 600)
	{
		if( (rpm_constant*rpm_lo_res/100) < MAX_STEP)
			rpm_constant += 45;
	}
	else if(rpm_lo_res >= 600 && rpm_lo_res < 900)
	{
		if( (rpm_constant*rpm_lo_res/100) < MAX_STEP)
			rpm_constant += 30;
	}
	else if(rpm_lo_res >= 900 && rpm_lo_res < 1200)
	{
		if( (rpm_constant*rpm_lo_res/100) < MAX_STEP)
			rpm_constant += 27;
	}
	else if(rpm_lo_res >= 1200 && rpm_lo_res < 1500)
	{
		if( (rpm_constant*rpm_lo_res/100) < MAX_STEP)
			rpm_constant += 20;
	}
	else if(rpm_lo_res >= 1500 && rpm_lo_res < 1800)
	{
		if( (rpm_constant*rpm_lo_res/100) < MAX_STEP)
			rpm_constant += 16;
	}
	else if(rpm_lo_res >= 1800 && rpm_lo_res < 2100)
	{
		if( (rpm_constant*rpm_lo_res/100) < MAX_STEP)
			rpm_constant += 13;
	}
	else if(rpm_lo_res >= 2100 && rpm_lo_res < 2400)
	{
		if( (rpm_constant*rpm_lo_res/100) < MAX_STEP)
			rpm_constant += 11;
	}
	else if(rpm_lo_res >= 2400 && rpm_lo_res < 2700)
	{
		if( (rpm_constant*rpm_lo_res/100) < MAX_STEP)
			rpm_constant += 9;
	}
	else if(rpm_lo_res >= 2700 && rpm_lo_res < 3000)
	{
		if( (rpm_constant*rpm_lo_res/100) < MAX_STEP)
			rpm_constant += 8;
	}
	else if(rpm_lo_res >= 3000 && rpm_lo_res < 3300)
	{
		if( (rpm_constant*rpm_lo_res/100) < MAX_STEP)
			rpm_constant += 7;
	}
	else if(rpm_lo_res >= 3300 && rpm_lo_res < 3600)
	{
		if( (rpm_constant*rpm_lo_res/100) < MAX_STEP)
			rpm_constant += 6;
	}
	else if(rpm_lo_res >= 3600 && rpm_lo_res <= 4000)
	{
		if( (rpm_constant*rpm_lo_res/100) < MAX_STEP)
			rpm_constant += 5;
	}
}
/******************************************************************************
* @brief    After calibrating the rpm constant, stepper motor goes to zero 
* 			and then goes to the tuned position 
* @param    none
* @return   none
* 
******************************************************************************/
void Animate_After_Calibration(void)
{
	if(State == Timeout_state)
	{
		if(MC_GetMotorPosition(0) == 0)
		{
			rpm_constant = temp_rpm_constant;
			State = Default_state;
		}
	}
}
/******************************************************************************
* @brief    Writes the parameter value to the EEPROM
* @param    none
* @return   none
* 
******************************************************************************/
void EEPROM_Write_WH(void)
{
	static UINT16 counter = 0;
	counter++;
	if(counter >= 3600)		// save the working hour in 1 hour
	{
		counter = 0;
		eeprom_error = EEPROM_Erase_Sector(WORKING_HOUR_ADDR);
		eeprom_error = EEPROM_Write_DoubleWord(WORKING_HOUR_ADDR, working_hour);
	}
}

/******************************************************************************
* @brief    Increments the working hour in each 6 minutes
* @param    none
* @return   none
* 
******************************************************************************/
void Increase_WH(void)
{
	static UINT16 counter = 0;
	counter++;
	if(counter >= 360)		// 6 dk da bir EEPROM'a yaz
							// increase working hour in each 6 minutes
					  		// (3600/3666)360= 353,51
	{
		working_hour++;
		counter = 0;
	}
}

/******************************************************************************
* @brief    Checks the ignition 
* @param    none
* @return   none
* 
******************************************************************************/
void IsIgnition_ON(void)
{
	if(ignition_interrupt_flag)
	{
		if (ignition_counter >= TIM_MSEC_100) 
		{
			ignition_on_flag = TRUE;
			rpm_hi_res = 0;
			rpm_lo_res = 0;
			ignition_interrupt_flag = FALSE;
			MCU_Reset();
		}
		else if (!IGNITION)
		{
			ignition_on_flag = FALSE;
			ignition_interrupt_flag = FALSE;
		}
	}
}
/******************************************************************************
* @brief    Resets the MCU 
* @param    none
* @return   none
* 
******************************************************************************/
void MCU_Reset(void)
{
	CPMUARMCOP = 0x00; 		//write any value except 0x55 or 0xAA cause MCU reset
}

void Sleep(void)
{
	//UINT32 j = 65000;
	State = Sleep_state;
	
	CPMUCOP_CR = 0x0;					// 0x0 Disable COP,
	TIM0TSCR1_TEN = 0;
	TIM1TSCR1_TEN = 0;
	
	LCDCR0_LCDEN  = 0;                  // Disable LCD
	TIM0TSCR1_TEN = 1;
	GPIO_PIF(T,3,1);
	GPIO_PPS(T, 3, 0);		   			// Polarity select 
	
	asm STOP;							// interrupt on Ignition will make the system wakeup
	//asm WAI;
}

