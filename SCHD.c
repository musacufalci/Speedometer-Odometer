
/*-----------------------------------------------------------------------------
Filename: SCHD.c
Description: This file sets up and arranges the timer.
Generated by Musa ÇUFALCI. Friday February 08 08.02.2019
----------------------------------------------------------------------------- */
/*
-----------------------------------------------------------------------------
A U T H O R I D E N T I T Y
-----------------------------------------------------------------------------
Initials Name Company
---------- --------------------- --------------------------------------------
Musa  ÇUFALCI
-----------------------------------------------------------------------------
R E V I S I O N H I S T O R Y
-----------------------------------------------------------------------------
Date Author Modification Description
Type
---------- ------ ------------- ----------------------------------
2016-03-29 MK Added First creating after project editing
----------------------------------------------------------------------------
*/


#include "SCHD.h"
/*   Task ID						Task Function			Time Task  */
#define SCHEDULER_TASKS_TABLE 											\
TABLE(Task1,						LCD_Data,					100			)\
TABLE(Task2,						Button_Check,				50			)\
TABLE(Task3,						GPIO_Read,					50			)\
TABLE(Task4,						Calibrate,					50			)\
TABLE(Task5,						Animate_After_Calibration,	50			)\
TABLE(Task6,                        EEPROM_Write_WH,	    	1000 		)\
TABLE(Task7,               		    Increase_WH,    	    	1000   	   	)\
TABLE(Task8,                        RPM_Read,					10          )

#undef TABLE
#define TABLE(a, b, c) a,

/* Enumeration of Tasks IDs */

typedef enum SchedulerTask_Enum_Tag {
	SCHEDULER_TASKS_TABLE
	MAX_NUM_TASKS
}scheduler_tasks_t;

#undef TABLE
#define TABLE(a, b, c) b,

/* Array of pointer to functions */

pt2Func task_table_ptr[MAX_NUM_TASKS] = {SCHEDULER_TASKS_TABLE};

#undef TABLE
#define TABLE(a, b, c) c,

UINT32 task_table_time[MAX_NUM_TASKS] = {SCHEDULER_TASKS_TABLE};

extern UINT16 RPM;

/*******************************************************************************
 *
 * @brief    SCHD_Scheduler
 * 			 infinite loop
 * @param    none
 * @return   none
 *
 ********************************************************************************/
void Scheduler_Init(void) {
	
	volatile UINT8 schd_task_idx;
	UINT32 schd_ticks = 0x00000000;		//MISRA deleted volatile
	volatile UINT32 schd_modulus;
	UINT16 schd_active_task;			//MISRA deleted volatile
	volatile UINT16 schd_task_mask;
	volatile UINT32 schd_previous_tick = 0x00000000;	
	
	for (;;) {
			schd_ticks = Clock_GetTicks();
			schd_active_task = 0x0000;

			__RESET_WATCHDOG();	// feeds the dog 
			
			IsIgnition_ON();
			
			if(ignition_on_flag)
			{
				MCU_Reset();
			}

			else if(no_ignition_flag)
			{
				no_ignition_flag = FALSE;
				Sleep();
			}

			if (schd_previous_tick != schd_ticks ) 
			{
				schd_previous_tick = schd_ticks;
				for (schd_task_idx = 0; schd_task_idx < MAX_NUM_TASKS; schd_task_idx++) 
				{
					schd_modulus = schd_ticks % task_table_time[schd_task_idx];
					schd_task_mask = 0x0000;
	
					if (0x00000000 == schd_modulus) 
					{
						schd_task_mask = (UINT16) (1UL << schd_task_idx);		//MISRA casting
						schd_active_task |= schd_task_mask;
					}
				}
				if (0x0000 != schd_active_task) 
				{
					for (schd_task_idx = 0; schd_task_idx < MAX_NUM_TASKS; schd_task_idx++) 
					{
						if ((1UL << schd_task_idx) & schd_active_task)			//MISRA casting
							(*task_table_ptr[schd_task_idx])();
					}
				}
			
			}
	}
}
